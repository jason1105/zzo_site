---
title: "30daysOS-第05天 结构体, 文字显示与GDT/IDT"
date: 2021-03-26T15:46:00+08:00
tags: [学习笔记, 学习, 笔记]
draft: false
description: "30天自制操作系统"
source: "http://hrb.osask.jp/"
---
#操作系统 #30daysOS 

# 结构体

正常使用的例子:

```
struct BOOTINFO {
	char cyls, leds, vmode, reserve;
	short scrnx, scrny;
	char *vram;
};

void HariMain(void) {
	struct BOOTINFO abc;
	
	// init
	abc.scrnx = 320;
	abc.scrny = 200;
	
	// process
	func(abc);
}
```

但是在这里, 是直接通过指针将结构体指向具体的内存.

```
	binfo = (struct BOOTINFO *) 0x0ff0;
	xsize = (*binfo).scrnx;
	ysize = (*binfo).scrny;
	vram = (*binfo).vram;
```

**箭头记号**

上面的例子中, 取得结构体的内容用的方法时 `(*binfo).scrnx`, 有没有更简单的方法呢? 有的, 箭头记号就可以实现这样的功能 `binfo->scrnx`, 这个箭头太厉害了, 不但拿到了结构体的内容, 还能定位到其中的元素.

# 文字显示

32位模式不支持BIOS调用.

C语言中的字符串都是以 `0x00` 结尾的.

字库中一个字符大小为 16 个字节, 例如下面的 A 由16个字节构成. 256 个字符一种占用 4096 个字节.  A 的字符编码是 0x41.
```txt
........
...**...
...**...
...**...
...**...
..*..*..
..*..*..
..*..*..
..*..*..
.******.
.*....*.
.*....*.
.*....*.
***..***
........
........
```



# GDT/IDT

**段表 GDT**

Global segment descriptor table

用来对内存分段, 这样就可以同时运行多个程序, 每个程序都可以从0x00开始使用自己的内存空间了.

在 16 位下, 如果写成 `MOV AL, [DS:EBX]` , 计算方式是 `DS * 0x10 + EBX` 得出一个地址, 然后取得地址的内容, 也就是说, EBX 需要加上一个值, 这个值是DS的0x10倍, 但在 32 位下就不是这样计算了, 32 位下, 这个值是 DS 所表示的段的首地址.  

一个段用8个字节保存下面的段信息:

- 段上限 (段大小, 即段字节数-1)
- 段基址 (起始地址)
- 段的管理属性

DS 是16位的, 无法保存所有的段信息, 所以只能保存段的代号. 由于 CPU 设计的问题, DS 的低 3 位不能使用, 所以只能保存 $2^{13} = 8192$ 个段, 段号范围 0~ 8191. 一个段的段信息使用8个字节保存, 所以需要 8192 * 8 = 65536 = 64KB 的空间保存, 而 CPU 没有这么多空间, 所以需要将这些数据保存到内存中, 这些数据就是 GDT. 

使用的时候将段号保存到 DS 寄存器中.

LGDT 是汇编中专门用于设定段数据的.

**中断记录表**

Interrupt descriptor table

中断: 设备有变化的时候, 会产生中断, cpu接收中断后保存现场, 然后转去进行相应的中断处理, 例如读取键盘输入的字符, 鼠标移动的距离等.  处理完成后回复现场.

IDT 记录了中断号与相应的中断处理函数的信息.