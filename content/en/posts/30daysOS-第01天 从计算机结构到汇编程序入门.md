---
title: "30daysOS-第01天 从计算机结构到汇编程序入门"
date: 2021-03-05T16:59:00+08:00
tags: [学习笔记, 学习, 笔记]
draft: false
description: "30天自制操作系统"
source: "http://hrb.osask.jp/"
---
sdsd
![image](/images/posts/a%20b.jpg)
![alt text](Isolated.png "Title")

# 第1天 从计算机结构到汇编程序入门

## 制作一个能够开机运行的程序

1. 编码
2. 编译成机器语言
3. 将机器语言加工成磁盘映象
4. 将映像文件写入磁盘, 制作成启动盘


### CPU 是什么

是一块集成电路版, 处理电信号, 也就是0和1. 将文字等进行编码后, 就可以处理了.

- 文字编码:  unicode
- 图像编码:  png, gif, jpeg
- 音频编码:  mp3, wav
- 视频编码:  avi, mpeg

### nask 汇编编译器

nask 是模仿  NASM 的编译器.

- DB 指令, 写入字节, 有了这个命令, 理论上可以写出任意的程序.
- RESB 填充空白字节
- $  表示当前已经输出的字节数


### 系统引导过程

1. 计算机读取软盘第一个扇区
2. 检查扇区最后两个字节内容, 如果是 55AA, 则该扇区是启动区, 从这个扇区的开头执行引导程序, 也就是 Initial Program Loader - IPL.

FAT 12 格式 ??? #todo 

下面是一个引导扇区代码:

```asm
; hello-os
; TAB=4

		ORG		0x7c00			; このプログラムがどこに読み込まれるのか

; 以下は標準的なFAT12フォーマットフロッピーディスクのための記述

		JMP		entry
		DB		0x90
		DB		"HELLOIPL"		; ブートセクタの名前を自由に書いてよい（8バイト）
		DW		512				; 1セクタの大きさ（512にしなければいけない）
		DB		1				; クラスタの大きさ（1セクタにしなければいけない）
		DW		1				; FATがどこから始まるか（普通は1セクタ目からにする）
		DB		2				; FATの個数（2にしなければいけない）
		DW		224				; ルートディレクトリ領域の大きさ（普通は224エントリにする）
		DW		2880			; このドライブの大きさ（2880セクタにしなければいけない）
		DB		0xf0			; メディアのタイプ（0xf0にしなければいけない）
		DW		9				; FAT領域の長さ（9セクタにしなければいけない）
		DW		18				; 1トラックにいくつのセクタがあるか（18にしなければいけない）
		DW		2				; ヘッドの数（2にしなければいけない）
		DD		0				; パーティションを使ってないのでここは必ず0
		DD		2880			; このドライブ大きさをもう一度書く
		DB		0,0,0x29		; よくわからないけどこの値にしておくといいらしい
		DD		0xffffffff		; たぶんボリュームシリアル番号
		DB		"HELLO-OS   "	; ディスクの名前（11バイト）
		DB		"FAT12   "		; フォーマットの名前（8バイト）
		RESB	18				; とりあえず18バイトあけておく

; プログラム本体

entry:
		MOV		AX,0			; レジスタ初期化
		MOV		SS,AX
		MOV		SP,0x7c00
		MOV		DS,AX
		MOV		ES,AX

		MOV		SI,msg
putloop:
		MOV		AL,[SI]
		ADD		SI,1			; SIに1を足す
		CMP		AL,0
		JE		fin
		MOV		AH,0x0e			; 一文字表示ファンクション
		MOV		BX,15			; カラーコード
		INT		0x10			; ビデオBIOS呼び出し
		JMP		putloop
fin:
		HLT						; 何かあるまでCPUを停止させる
		JMP		fin				; 無限ループ

msg:
		DB		0x0a, 0x0a		; 改行を2つ
		DB		"hello, world"
		DB		0x0a			; 改行
		DB		0

		RESB	0x7dfe-$		; 0x7dfeまでを0x00で埋める命令

		DB		0x55, 0xaa

```

## 机器码

下面是操作系统的代码, 是二进制数据, BIOS 将这些代码读入到内存, 然后 CPU 开始解释这其中的机器码.

实际上这里面包含了业务(可以被 CPU 识别的机器码)和数据.

```bin
eb 50 90 48 45 4c 4c 4f 49 50 4c 20 02 01 01 20 02 e0 20 40 0b f0 09 20 12 20 02 20 20 20 20 20 40 0b 20 20 20 20 29 ff ff ff ff 48 45 4c 4c 4f 2d 4f 53 20 20 20 46 41 54 31 32 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 b8 20 20 8e d0 bc 20 7c 8e d8 8e c0 be 74 7c 8a 04 83 c6 01 3c 20 74 09 b4 0e bb 0f 20 cd 10 eb ee f4 eb fd 0a 0a 68 65 6c 6c 6f 2c 20 77 6f 72  .... 
```

## 简陋的汇编

CPU 喜欢上面的代码, 但对于人来说很难读懂, 所以我们引入了汇编语言.

下面的程序和后面将要做的汇编程序是一样的, 只不过这里全部使用了 DB 伪指令. 像是 JMP 和 MOV 这样的指令在这里全部换成了机器码, 然后通过 DB 伪指令直接将机器码写到存储中了. CPU 执行的时候, 会将存储中的这些数据读入到内存, 然后从一个地址开始, 将内存中的数据解释为指令, 并运行.

这些和上面的机器码其实是一样的. 要说有什么好处, 好处是不需要二进制编辑器也可以编辑机器码了(笑).

```asm
	DB	0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
	DB	0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00
	DB	0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00
	DB	0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
	DB	0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff
	DB	0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4f
	DB	0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41
	DB	0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00
	RESB	16
	DB	0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
	DB	0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
	DB	0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
	DB	0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
	DB	0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65
	DB	0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72
	DB	0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00
	RESB	368
	DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
	DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
	RESB	4600
	DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
	RESB	1469432
```

## 参考
[# 30日でできる！ OS自作入門](http://hrb.osask.jp/)
[OSDev.org](http://www.osdev.org/)
