---
title: "30daysOS-第12天 定时器(1)"
date: 2021-04-02T10:46:00+08:00
tags: [学习笔记, 学习, 笔记]
draft: false
description: "30天自制操作系统"
source: "http://hrb.osask.jp/"
---
#操作系统 #30daysOS 

# 简介

**时钟周期**

时钟周期是 CPU 执行一个最基本动作所需要的时间, 是 CPU 频率的倒数.

**时钟周期的作用**

假设有一台挖机, 一台卡车, 完成一个挖土作业, 需要几步:

- 挖机挖一勺土放进卡车
- 卡车将土运到目的地
- 卡车卸车
- 卡车回到挖机旁边

这个作业需要4步完成, 也就是四条指令, 假设每条指令的执行时间都一样, 每条指令都需要前面的指令完后才能执行, 不然可能空车运到目的地的情况, 或者挖机放土的时候卡车还没有就位. 怎么控制呢? 假设用频率均匀的铃声控制, 第一声铃声响的时候执行第一条, 第二声铃声响的的时候执行第二条, 以此类推.  这个铃声就是脉冲信号, 是由晶振产生的. 这个脉冲信号的周期就叫时钟周期. 时钟周期的倒数是频率. 我们常说的 CPU 核心频率 2GHz意思就是1秒钟产生2G个脉冲. 两个脉冲之间的时间间隔就是一个时钟周期, 一个时钟周期内, CPU 内部的处理单元可以执行一次运算, CPU 内部有多个不同的处理单元(相当于流水线上的不同工人), 这些处理单元可以并行执行.  

简单的指令只需要一次处理, 在一个时钟周期内就可以执行完毕, 例如 MOV 以及上面的例子中的四个步骤. 复杂指令则需要多个处理也就是多个时钟周期, 例如 ADD.

时钟周期越短, 频率越高, 处理速度越快. ( 处理单元接收一次时钟脉冲就完成一次处理, 所以处理单元的工作是由脉冲开启的, 一个指令需要多次处理, 意味着需要经过多个周期, 这和一个周期的长短无关.)

> 流水线的思想是, 第一台卡车运送土的同时, 挖机不停止, 将土放进第二台卡车, 这不就提高了生产效率吗. 这就好比汽车装配线, 流水线的上工人就是 CPU 内部的可并行的处理单元.

**定时器**

CPU 不关心周期的长短, 所以系统中只有周期的概念, 没有时间的概念. 定时器就是用来解决时间的问题的. 系统中的定时器叫 PIT - Programmable Interval Timer. 开启 PIT 后, 会占用 PIC (Programmable Interrupt Control), 以固定的间隔发送 IRQ0 中断.

**单片机**

 单片机又称单片微控制器，它不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一个芯片上。相当于一个微型的计算机，和计算机相比，单片机只缺少了I/O设备。
 
 # 使用定时器
 
 设定 PIT 的中断频率, 即经过`中断周期`后产生一个中断.  `中断周期` 设置为0等同于65536.
 
 ## **定义结构体**
 
 ```c
struct TIMER {
	unsigned int timeout, flags; // 超时时间, 状态: 未分配 / 已分配 / 使用中
	struct FIFO8 *fifo;  // 消息队列
	unsigned char data;  // 超时后写入队列的信息
};
struct TIMERCTL {
	unsigned int count; // PIT 中断次数
	struct TIMER timer[MAX_TIMER];  // 在控制器中定义多个
};
```
 
 ## **(主程序中)开启定时器**
 
- 设定IDT, 加入 IRQ0
- 初始化PIT
- 向 PIC0 发送指令, 开启PIT中断的管脚

 ## **汇编部分**

- CPU 接收定时器中断, 调用中断服务程序

 ## **初始化PIT**

 ```c
 void init_pit(void)
{
	io_out8(PIT_CTRL, 0x34);  // out 0x0043, 0x34
	io_out8(PIT_CNT0, 0x9c);  // out 0x40, <中断周期低8位>
	io_out8(PIT_CNT0, 0x2e);  // out 0x40, <中断周期高8位>
	return;
}
 ```

 ## **中断服务程序**
 
- 告诉IRQ已经收到消息
- 中断计数器+1     -------- #  1秒钟100次中断
- 遍历定时器集合
	- 循环开始
	- 如果状态为 "使用中", 则超时时间-1
	- 如果超时间为0, 则将状态改为 "已分配", 然后发送消息到消息队列
	- 循环结束
 
## **主程序**

- 初始化一个消息队列
	- 初始化开始
	- 初始化队列空间
	- 设定队列大小
	- 队列空间空间
	- 队列标志
	- 读取指针
	- 写入指针
	- 初始化结束
- 取得一个定时器
	- 遍历定时器集合
	- 找到一个未使用的定时器, 返回该定时器的指针
- 初始化这个定时器
	- 为定时器分配消息队列 (超时后将信息发送到该队列)
	- 设置超时后发送的信息
- 设定这个定时器的超时时间, ----------- # 剩余时间.

## 优化定时器

- 允许使用多个定时器
- 超时时间从 "剩余时间" 改为 "目标时间". 例如: 剩余10s, 则10s后超时.  目的时间是第 1000s, 则系统时间到达 1000s 后超时. 两者作用相同. 不同点是: "剩余时间" 需要减法计算, 直到减到0为止即为超时.  而 "目的时间" 只需要和当前时间做比较, 小于等于当前时间即为超时.![[Pasted image 20210403141224.png]]
- 每次进入 [[30daysOS-第12天 定时器(1)#中断服务程序]] 都需要迭代整个集合, 可以优化: 第一次进入时迭代整个集合, 同时将超时时间最小且还未超时的 timer 作为下一次进入中断服务程序时要处理的 timer, 将其保存在 next 变量中. 下面是中断服务处理程序的例子: ![[Pasted image 20210403141422.png]]


 
# 参考

- 晶振原理: https://www.zhihu.com/zvideo/1352623477980053504
- 单片机 : https://baike.baidu.com/item/%E5%8D%95%E7%89%87%E6%9C%BA/102396?fr=aladdin
- CPU 的流水线结构: https://wenku.baidu.com/view/b6528521c5da50e2524d7f41.html