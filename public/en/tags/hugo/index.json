[{"content":"RUST choco install visualstudio2019buildtools\n注意 windows 下定位安装文件最好从具体盘符开始.\n镜像资源 新建一个文件 ~/.cargo/config\n1 2 3 4 5 6  [source.crates-io] replace-with = \u0026#39;tuna\u0026#39; [source.tuna] registry = \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\u0026#34;   构建帮助文档 cargo doc \u0026ndash;open\n语法 语法 表示静态方法调用, 例如: String::new(), 这个静态方法是定义在 structure 中的一个 function, 常常用来生成一个 struct 的实例, 注意 struct 中的 method 和 method 的区别. :: 既可以用于关联 function, 也可以用于 module 的 namespace.\n语法 声明方法返回值.\n语法 match 的匹配项的返回值.\n03 03 01 1 注意, 常量永远是 immutable. const 类型必须标明类型.\n将所有硬编码变量声明为 const.\nshadowing\n使用 let 可以将一个 immutable 变量重新赋值.\n 为什么使用 Immutable?\n如果我们认为一个变量不会改变, 基于此写了代码A, 但在未来的某个时间点它被另一段代码B改变了, 就会导致代码A的行为超于预期, 由此产生的Bug是很难处理的. 所以使用了 immutable , 这样一来, 由 rust 保证这个变量是不变的, 您无需跟踪变量是否被改变就能保证代码A的正确性. 另外, immutable也用来改善并发程序.\n 03-02 无符号比有符号的正整数范围大一倍+1\n数字默认是 i32\nNumber literals\tExample\nDecimal\t98_222\nHex\t0xff\nOctal\t0o77\nBinary\t0b1111_0000\nByte (u8 only)\tb\u0026rsquo;A'\n通过模式匹配分解 tuple\nfn main() {\nlet tup = (500, 6.4, 1);\nlet (x, y, z) = tup; println!(\u0026quot;The value of y is: {}\u0026quot;, y);  }\n元组\n组合不同类型的元素\n数组\n数组分配在 stack 上. 是不变的.\n用来定义年份等.\nlet a: [i32; 5] = [1,2,3,4,5];\nlet a = [3; 5];\nvector\n可变的.\n03 03 方法定义没有顺序\n方法参数必须声明其类型.\nlet x = (let y = 6); 这样的语句是错误的. 因为一个声明块没有返回值.\nlet x = y = 3; 也是错误的.\n表达式是用的最多的, 在 rust 中.\nlet x = 6; // 这里的 6 是一个表达式.\n{} 这也是一个表达式\n通常在方法的最后一行返回， 也可以使用 return 提前返回.\n03 05 if 必须要{}\nif 的{} 可以是代码块, 也可以表达式.\nloop 中的 break 可以将值返回.\n04 04 01 ownership2 复杂的数据类型保存在堆上, 有自己的 owner.\n下面这些数据类型直接保存在栈上, 没有 owner:\n![[Pasted image 20210704183028.png]]\n调用方法b, 方法b会将本地变量保存在栈上.\nownership作用\n 跟踪哪些程序用了哪些变量在堆上 减少堆上的重复数据 清理堆上无用的数据  ownership规则, 3个\n 变量都有owner 同一时刻只能有一个 当owner结束时, 变量也被丢弃  1 2  lets=\u0026#34;hello\u0026#34;;lets=String::from(\u0026#34;hello\u0026#34;);  前者是字面量, 不可变, 即使 mut也不行, 因为它分配在栈上, 它有固定大小.\n后者存在堆上, mut 后可变.\n一个变量超出 scope 后(离开方法{}之后), rust 调用 drop 函数, 变量的持有者在 drop 函数中释放变量所占有的内存.\n复合变量的复制实际上移动了 owner. move 可以从 immutable 变成 mutable.\nlet s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1; // s1 已经无效了. // 方法调用也是同样的, 例如 let s3 = String:from(\u0026quot;hello\u0026quot;); foo(s3); fn foo(s: String) { ... } // println!(\u0026quot;s3: {}\u0026quot;, s3); // error 上面的问题使用 clone() 可以解决, clone 会在堆上重新分配一个与 s1 具有相同内容的对象. (但不是同一个对象).\n1 2 3 4 5  letmuta=String::from(\u0026#34;hi\u0026#34;);letb=a.clone();a=String::from(\u0026#34;hello\u0026#34;);println!(\u0026#34;a {}\u0026#34;,a);// a hello println!(\u0026#34;b {}\u0026#34;,b);// b hi   调用完 foo 后, s3 变量也无效了. 如果还想使用 s3, 可以在foo() 方法中返回一个元组, include the parameter of input.\n1 2 3 4 5 6 7  fn foo(s: String){letsize=s.len();// 模拟一个业务 (s,size)// 返回业务结果, 同时返回 s }lets4=\u0026#34;a\u0026#34;;s4=foo(s4).0;  这里产生了一个问题, 每次调用方法都要返回原始参数值.\nHow we resolve this problem.\n 栈和堆\n分配\n栈上的数据必须有确定的大小.\n对于那些未知大小的数据或者可能在运行时改变大小的数据, 则必须保存在堆上.\n栈上分配更快, 因为无需查找可用空间.\n在堆上分配则需要查找到足够的空间, 还要记录每个数据所占用的空间以便进行下一次分配\n使用\n栈的读取更快.\n堆的读取则需要跟随指针进行跳转. (指针可以分配在栈上, 因为指针的大小是固定的.)\n当调用一个函数的时候, 传递给函数的指针(对变量的引用)以及函数本身的局部变量都会被压入栈, 在函数体结束的时候, 它们都会被弹出栈.\nOwnership 要处理的问题就是: 跟踪那些使用了堆空间的代码, 减少堆中重复的数据, 清理堆中无用的数据, 从而避免内存溢出.\n理解 Ownership 存在的意义就是为了管理堆, 可以帮助你理解代码工作的方式.\n 04 02 reference Think about reference in Java. Just post reference of object when call a method.\nString a = new String\nRef in Rust is a reference pointed the owner of original variable.\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let len = calculate_length(\u0026amp;s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() } ![[Pasted image 20210721232715.png]]\ns -\u0026gt; s1 -\u0026gt; data in memory\ns is not owner of the object on heap. s1 is owner.\nremember that s is immutable, so you can\u0026rsquo;t change the value in calculate_length() unless use \u0026amp;mut.\nMutable reference\nto address data races, Rust don\u0026rsquo;t allow use \u0026amp;mut more than one time with same variable.\nscenario:\n  multiple read was allowed\nlet mut s = \u0026hellip;\nlet r = \u0026amp;s;\nlet r1 = \u0026amp;s;\n  mix read and write wasn\u0026rsquo;t allow\nlet mut s = ..\nlet r1 = \u0026amp;s; // no problem\nlet r2 = \u0026amp;s; // no problem\nlet r3 = \u0026amp;mut s; // BIG PROBLEM\n  上述方式解决了同步变量的问题. 可以同时读, 但不能同时写, 即在一个 scope 中, 只能有一个写操作, 离开作用域后, 变量无效, 例如:\n对于 i32 等原始的类型, 直接赋值就是 copy, 保存在堆栈上. 使用 \u0026amp; 则是引用, Rust 把 \u0026amp; 表述为 borrow, 临时借用一下, 所以原始值你不能变哦, 看下面的例子\n1 2 3 4 5 6 7 8 9 10 11 12  letmutx=5;lety=x;// copy value of x to y, store on stack println!(\u0026#34;y = {}\u0026#34;,y);x=6;println!(\u0026#34;y = {}\u0026#34;,y);letmutx=5;lety=\u0026amp;x;// reference to x, y is borrow of x println!(\u0026#34;y = {}\u0026#34;,y);x=6;// x is borrowed, and will use in the future, so it won\u0026#39;t be modify println!(\u0026#34;y = {}\u0026#34;,y);// here, use y that is borrow of x   编译出错, 因为 x 已经 borrow 出去了, 所以 x = 6 是非法的操作.\nBorrow rules: ^79ef45\n There are only one mutable reference or any number of immutable exists at one time. (but not both of) Reference must be valid.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  /* let mut y = String::from(\u0026#34;1\u0026#34;); y 的数据类型(指向的内存区域的类型)是 String, y 是资源 String::from(\u0026#34;1\u0026#34;) 的所有者(owner), 在编译期, y 被替换为真正保存了 \u0026#34;1\u0026#34; 这个数据的内存地址. 例如: 0x09e3a317 因为使用了 mut, 所以 y 区域的内容可以修改, 换句话说, 因为使用了 mut, 所以 \u0026#34;1\u0026#34; 所在的内存区域是可以被编辑的. 总结: 申请了一块可以编辑的内存标记为 y, 里面存放了 String::from(\u0026#34;1\u0026#34;) */letmuty=String::from(\u0026#34;1\u0026#34;);// 注意, y 是 owner, 决定了什么时候可以释放内存. 即 0x09e3a317 地址一旦离开作用域, 将被回收. y=String::from(\u0026#34;11\u0026#34;);// 编辑内存中的内容 println!(\u0026#34;y: {}\u0026#34;,y);// y: 11 println!();/* \u0026amp; 在 Rust 中叫 borrow, 暂时借用, 并不是变量的主人, 所以不拥有变量. \u0026amp; 可以理解为 c语言 中的取地址操作, 例如: \u0026amp;y 的意思是: 借用一下 y. 那怎么借用呢? 我只要 y 的地址, 通过 y 和数据打交道, 所以 y 还是数据的owner, 我只是借用一下, \u0026amp;mut y 的意思是, 借用一下, 同时还有修改数据的权限 例如: let a = \u0026amp;y; 的意思是, 申请了一块只读内存, 标记为a, 里面存放的是 y 的地址(且不能修改成别的地址). a 只可以使用但不能修改 y (这个 a 不就是指针嘛) let a = \u0026amp;mut y; 的意思是, 申请了一块只读内存, 标记为a, 里面存放的是 y 的地址(且不能修改成别的地址). a 有权修改 y 的内容( a 是一个可变指针) let mut a = \u0026amp;y; 的意思是, 申请了一块可读写内存, 标记为a, 里面存放的是 y 的地址(也可以修改成存放 z 的地址). a 只可以使用但不能修改 y (这个 a 不就是指针嘛) let mut a = \u0026amp;mut y; 的意思是, 申请了一块可读写内存, 标记为a, 里面存放的是 y 的地址(也可以修改成存放 z 的地址), a 有权修改 y 的内容( a 是一个可变指针) borrow 有两个规则: 1. 同一时刻, 一个资源只能有一个 \u0026amp;mut borrow 或者多个 \u0026amp; borrow, 2. 引用必须是有效的. 即不能引用一个不存在的东西. borrow 的两个规则可以可以理解为读写锁, 在一个作用域(事务)当中, 对资源进行锁定以避免竞争条件, 要么都是读锁(s), 要么只有一个写锁(x). \u0026amp; 理解为读锁. \u0026amp;mut 理解为写锁. 这样设计的好处: 避免一段代码中不同的逻辑之间的干扰(类似事务之间的干扰) 隐含的 borrow: 在方法参数中, 例如 println!() */{println!(\u0026#34;-------------- Block A\u0026#34;);leta=\u0026amp;muty;// a 的数据类型(指向的内存区域的类型)是 \u0026amp;mut String, 通过 mut 引用 y (拥有了 y 的 x 锁), // let mut c = \u0026amp;mut y; // c 也想要 y 的 x 锁, 这是不可能的, y 上只能加一把 x 锁. 已经被 a 占用了, 且 a 还没有释放. // y = String::from(\u0026#34;111\u0026#34;); // owner 当然有最大权限, 但此时因为 y 上有一把 x 锁被 a 占用, 且 a 还没有释放, 所以 owner 也无权修改. // println!(\u0026#34;y: {}\u0026#34;, y); // 这里的 y 作为了方法参数, 是 \u0026amp; borrow (相当于 s 锁), 因为 y 上有 x 锁, 这个 borrow 是不被允许的. *a=String::from(\u0026#34;2\u0026#34;);// a 拥有 x 锁, 可以写 y. 此后 a 作用域结束, 释放了 x 锁. println!(\u0026#34;y: {}\u0026#34;,y);// 现在 y 上没有任何锁, y: 2 y=String::from(\u0026#34;111\u0026#34;);// 因为 a 的作用域已经结束, y 上没有锁, 所以现在 owner 可以修改了. letmutc=\u0026amp;muty;// y 上没有锁, c 现在可以加一把 x 锁 //println!(\u0026#34;y: {}\u0026#34;, y); // y 上有 c 加的锁, 且 c 还没有释放, 所以不能再 borrow *c=String::from(\u0026#34;3\u0026#34;);// c 修改了 y, 此后 c 作用域结束, 释放 x 锁. println!(\u0026#34;y: {}\u0026#34;,y);// 现在 y 上没有任何锁, y: 3 println!();}{println!(\u0026#34;-------------- Block B\u0026#34;);leta=\u0026amp;y;// a 拥有了 y 的 s 锁 // let c = \u0026amp;mut y; // c 想要 y 的 x 锁, 这是不可能的, 因为 s 和 x 不能共存, a 已经持有 s 锁且 a 还没有释放, 所以无法加 x 锁. // y = String::from(\u0026#34;111\u0026#34;); // owner 当然有最大权限, 但此时因为 y 上有一把 s 锁, 且还未释放, 所以 owner 也无权修改. letc=\u0026amp;y;// 但 c 可以得到 y 的 s 锁, 共享锁可以加多次, 不多 c 并没有使用, 所以随即这把 s 锁就失效了 println!(\u0026#34;y: {}\u0026#34;,y);// 这里的 borrow 相当于 s 锁, 因为 s 锁可以加多次, 所以没有问题. y: 3 println!(\u0026#34;a: {}\u0026#34;,a);// 此后 a 作用域结束, 释放了 s 锁. a: 3 y=String::from(\u0026#34;111\u0026#34;);// y 上没有任何锁, y 是owner, 当然可以修改 println!(\u0026#34;y: {}\u0026#34;,y);// y: 111 println!();}  04 03 slice A string slice is a reference to part of a String\nslice data structure? #todo\n\u0026amp;str is string slice type.\nSlice is a pointer pointing to a specific point.\nfn main() { let s = String::from(\u0026quot;hello world\u0026quot;); let hello = \u0026amp;s[0..5]; // Remeber to use \u0026amp; let world = \u0026amp;s[6..11]; } ![[Pasted image 20210704163935.png]]\n05 Structs self in implementation of struct means the object itself or current module.\nSelf is a type of module or struct. \u0026amp;self is a shorthand of self : \u0026amp;Self\n self when used as first method argument, is a shorthand for self: Self. There are also \u0026amp;self, which is equivalent to self: \u0026amp;Self, and \u0026amp;mut self, which is equivalent to self: \u0026amp;mut Self.\nSelf in method arguments is syntactic sugar for the receiving type of the method (i.e. the type whose impl this method is in). This also allows for generic types without too much repetition.\nhttps://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self\n 声明 特殊情况\nfn main() { struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); } 06 enumeration 什么是枚举 枚举是一种数据类型(可以想象成一个类), 这个类包含一个有边界的该种类型的数据集, 该数据集不能动态扩展.\n例如: 下面的 Person 包含了一个 Person 类型的数据集, 其中有两个元素 MAIL 和 FEMAIL.\nenum Person { MAIL, FEMAIL, } 可以给类型中添加元素:\nenum Person { MAIL(\u0026quot;Lee\u0026quot;), FEMAIL(\u0026quot;Lily\u0026quot;); // NOTICE here, use ; instead of , String name; private Person(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } }  枚举的使用: 当定义的数据类型存在不同的子类型时, 例如: 定义一个返回值 Result 类型, 且这个返回值类型有正常和异常两种情况, 这种场合就是一个典型的枚举.\n\u0026gt; rust \u0026gt; enum Result\u0026lt;T, E\u0026gt; { \u0026gt; Ok: T, \u0026gt; Err: E, \u0026gt; } \u0026gt; \n 07 Package, Crates, and Modules  Packages: A Cargo feature that lets you build, test, and share crates. cargo 建立的一个工程是一个 package. 一个 package 包含一个或者多个 crate. 一个 package 只能包含 0 个或者 1 个 Lib crate, 但可以包含多个二进制可执行文件 crate. 且一个 package 必须有一个 crate. Crates: A tree of modules that produces a library or executable. 一个 crate 是一个可执行文件或者一个库文件, crate 相当于一个命名空间. 里面包含 module 的树形结构. main.rs 是一个 crate 的根. lib.rs 也是一个 crate 的根. Rust 默认 main.rs 和 lib.rs 都是 crate, 且名字和 package in Cargo.toml 一样. 一个 package 可以多个二进制 crates, 只要把它们放在 src/bin 下即可. Modules and use: Let you control the organization, scope, and privacy of paths. 提供一个逻辑的分层. 注意: 所有模块都指向根模块 crate Paths: A way of naming an item, such as a struct, function, or module  07 01   Package: cargo.toml 文件所在项目的名字, 定义在 cargo.toml 的 [package].name 中.\n  Binary crate: 可执行 crate\n  Library crate: 库 crate\n  新建一个 binary: cargo new \u0026lt;package_name\u0026gt;\n  新建一个 library: cargo new --lib \u0026lt;package_name\u0026gt;\n  包的绝对引用和相对引用:\n 绝对引用: 如果 lib 是固定的, client 有可能变化, 用绝对引用 相对引用: 如果 lib 和 client 的相互关系是稳定的, 用相对引用  https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#:~:text=The%20reason%20is%20that%20child%20modules%20wrap%20and%20hide%20their%20implementation%20details%2C%20but%20the%20child%20modules%20can%20see%20the%20context%20in%20which%20they%E2%80%99re%20defined\n07 04 use use 可以用于\n module struct enum function : 注意很少使用 use 来导入一个 function. 因为使用的时候容易产生混淆.  use std::cmp::Ordering; use std::io; equals -\u0026gt;\nuse std::{cmp::Ordering, io}; use std::io; use std::io::Write; equals -\u0026gt;\nuse std::io::{self, Write}; // use std::io and std::io::Write use std::collections::*; // used for test 导入一个模块的场合, 直接在根目录下加一个文件 front_of_house.rs, 然后在 lib.rs 中使用 mod :\nmod front_of_house;\n如果 front_of_house 中还包含单独文件的子模块, 则那个子模块必须放在 front_of_house 文件夹中.\n/- | lib.rs | front_of_house.rs |---front_of_house front_of_house.rs 这样的原因是因为 rust 的 module 是 full qulification. 也就是说存在 这样的 module:\n io.rand app.rand  如果把每个模块单独定义在文件中, 就会出现两个名为 rand.rs 的文件.\ncrate 可以作为相对路径中的根节点. 注意: 一个 package 中的多个 crate 具有相同的名字, 所以 crate 指的是当前文件所在 crate 的根.\n08 08 01 Vector Vector 中的元素使用的时候加上 *.\n1 2 3 4 5 6  fn main(){letmutv=vec![100,32,57];foriin\u0026amp;mutv{*i+=50;}}  08 02 String rust 核心只有一种 string type, 那就是 str. 而 String 类型是标准库函数提供的. 标准库也提供其他类型的 string type, 例如: OsString OsStr CString CStr\n08 03 HashMap 对于实现了 Copy 的类型, 例如 i32, HashMap 持有副本, 对于 Ownerable 的类型, 例如 String, 会将 owner 交给 HashMap.\n更新已有值, 下面的例子是统计单词出现的次数:\n1 2 3 4 5 6 7 8 9 10  lettext=\u0026#34;hello world wonderful world\u0026#34;;letmutmap=HashMap::new();forwordintext.split_whitespace(){letcount=map.entry(word).or_insert(0);// return the value if exist, or insert new value and return 0 *count+=1;}println!(\u0026#34;{:?}\u0026#34;,map);  entry() 和 or_insert() 返回的是 \u0026amp;mut v , 通过 * 解引用后这个值可以直接修改.\n09 如果正在写一个函数, 当错误发生时, 不要 panic, 而是把错误返回.\n10 Generic Types, Traits, and Lifetimes3 trait 两个作用:\n Trait: 定义行为接口 Trait Bound: 约束泛型, 例如 \u0026lt;T: Display\u0026gt;, 指的是实现了 Display trait 的类型  Rust 使用了单态化, 所有的泛型在编译期会被替换成实际的类型. 也就是说, 如果一个泛型方法被调用, Rust 会维持多个实例方法对应着每个调用. 这样就不会因为使用了泛型而牺牲性能. (但是我想, 这样牺牲的是空间, 因为泛型参数的增加可能导致在编译期生成很多实例.)\ntraits4 约束条件: trait 和 待绑定的结构必须至少有一项是 local的. 也就是说, 不能将第三方库中的 trait 与第三方库中的结构绑定在一起.\ntrait 中的默认方法可以调用 trait 当中的其他方法, 即使那些方法抽象的. 这和抽象类有些类似. 如果方法 a() 是一个默认方法, 我们覆盖了 a(), 则不能在我们的方法当中调用默认方法 a().\nTrait Bound\n限制泛型的范围. 可以理解为: 要求一个参数(任意类型)具有指定的特性.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // single pubfn notify(item1: \u0026amp;implSummary,item2: \u0026amp;implSummary){// both item1 and item2 must have implemented Summary pubfn notify\u0026lt;T: Summary\u0026gt;(item1: \u0026amp;T,item2: \u0026amp;T){// Same as previous notify() // multiple pubfn notify(item: \u0026amp;(implSummary+Display)){// item must has implemented Summary and Display pubfn notify\u0026lt;T: Summary+Display\u0026gt;(item: \u0026amp;T){// Same as previous notify() // use where clause fn some_function\u0026lt;T: Display+Clone,U: Clone +Debug\u0026gt;(t: \u0026amp;T,u: \u0026amp;U)-\u0026gt; i32 {// t must has implemented trait of Display and Clone, u must has implemented trait of Clone + Debug. fn some_function\u0026lt;T,U\u0026gt;(t: \u0026amp;T,u: \u0026amp;U)-\u0026gt; i32 whereT: Display+Clone,U: Clone +Debug{// convenient implements   return a trait\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String; } pub struct NewsArticle { pub headline: String, pub location: String, pub author: String, pub content: String, } impl Summary for NewsArticle { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026quot;{}, by {} ({})\u0026quot;, self.headline, self.author, self.location) } } pub struct Tweet { pub username: String, pub content: String, pub reply: bool, pub retweet: bool, } impl Summary for Tweet { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026quot;{}: {}\u0026quot;, self.username, self.content) } } fn returns_summarizable() -\u0026gt; impl Summary { // HERE Tweet { username: String::from(\u0026quot;horse_ebooks\u0026quot;), content: String::from( \u0026quot;of course, as you probably already know, people\u0026quot;, ), reply: false, retweet: false, } } 10 03 The Borrow Checker5 泛型生命周期语法\n\u0026amp;'\u0026lt;lifetime\u0026gt; [mut] \u0026lt;type\u0026gt;\n例如:\n\u0026amp;i32 // a reference \u0026amp;'a i32 // a reference with an explicit lifetime \u0026amp;'a mut i32 // a mutable reference with an explicit lifetime 生命周期本身没有意义, 其意义在于指出各个参数之间的生命周期的关系. 返回值生命周期是 input lifetime 的交集.\nRust 根据三个规则推断 lifetime in function or method declaration\n 每一个引用的参数默认有自己的生命周期. 例如: 对于 fn foo(x:\u0026amp;i32, y: \u0026amp;i32) 来说, Rust 默认会为每个参数指定一个生命周期: fn foo\u0026lt;'a, 'b\u0026gt;(x: \u0026amp;'a i32, y: \u0026amp;'b i32). 如果只有一个输入参数, 则所有的输出参数与输入参数的生命周期保持一致. 例如: 对于 fn foo(x: \u0026amp; i32) -\u0026gt; \u0026amp;i32 来说, Rust 自动指明生命周期 fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32) -\u0026gt; \u0026amp;'a i32. 如果输入参数中有 \u0026amp;self 或者 \u0026amp;mut self, 则输出参数的生命周期与保持一致. 这样一来, 对于所有包含了 \u0026amp;self 或者 \u0026amp;mut self 的 method 来说, 生命周期的声明就可以省略了.  'static means a lifetime duration same as whole application. All string literal have this lifetime.\nstruct 的生命周期\n1 2 3  struct ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt;{part: \u0026amp;\u0026#39;astr,}  ImportantExcerpt 和其字段 part 的生命周期一致.\n11 test6 11 01 Write a test 自定义的 struct 和 enums 需要实现 PartialEq 和 Debug, 前者用来比较, 后者用来输出. 可以使用 #[derive(PartialEq, Debug)] 在自定义的 struct 和 enums 上.\n assert!() assert_eq!() assert_ne!() #[should_panic(expected = \u0026quot;\u0026quot;)]  1 2 3 4 5 6 7  #[test]fn greeting_contains_name(){letresult=greeting(\u0026#34;Carol\u0026#34;);assert!(result.contains(\u0026#34;Carol\u0026#34;),\u0026#34;Greeting did not contain name, value was `{}`\u0026#34;,// format! result);}  11 02 Controll a test7 指定测试线程数量\n指定线程数量可以避免并行测试对共享资源的读写造成的失败.\n$ cargo test -- --test-threads=1 输出\n$ cargo test -- --show-output 执行部分测试\n$ cargo test \u0026lt;str\u0026gt; 只要包含了 str 的测试方法都会被执行. 例如下面执行了包含 bu 的测试方法, 测试报告中同时显示 8 filtered out, 说明有 8 个测试方法没有执行.\n1 2 3 4 5 6 7 8  $ cargo test gu running 2 tests test tests2::guess_panic ... ok test tests::guess_panic ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 8 filtered out; finished in 0.00s   忽略测试\n1 2 3 4 5  #[test]#[ignore]fn expensive_test(){// code that takes an hour to run }  We can specify cargo test -- --ignored to include ignored test.\n11 03 Integration test  Make dir tests in root of project. Add rs file in tests Add annotation [test] on every test method. Notice that every rs file is an independent crate. Run particular test using cargo test --test \u0026lt;name\u0026gt;  1 2 3 4 5 6 7  // Listing 11-13: An integration test of a function in the adder crate usecontrolling_how_test;#[test]fn it_adds_two(){assert_eq!(4,controlling_how_test::add_two(2));}  Use setup of common\n Create a common dir in tests Create mod.rs in common Import module of common by using mod common;  1 2 3 4 5 6 7 8 9  // Listing 11-13: An integration test of a function in the adder crate usecontrolling_how_test;mod common;#[test]fn it_adds_two(){common::setup();assert_eq!(4,controlling_how_test::add_two(2));}  12 Command Line Program see program.\n13 Closure and Iterator 13 01 Closure 函数不能捕获此法作用域, 闭包可以捕获此法作用域.\n1 2 3 4 5 6 7 8 9 10  fn main(){letx=4;fn hello(){println!(\u0026#34;x: {}\u0026#34;,4);// error }}  一个闭包只能推断绑定到一种类型, 如果是两种, 编译出错, 例如:\n1 2 3 4  letexample_closure=|x|x;lets=example_closure(String::from(\u0026#34;hello\u0026#34;));letn=example_closure(5);  13 02 Iterators 调用 ite.next() 需要 mutable, 因为其内部状态会变化, 使用 for 则不会\nvec.iter() 返回 immutable, vec.into_iter() 返回 mutable.\n14 Cargo and Crates.io 14 02 Publishing 文档注释 ///, 文档注释中的测试代码可以通过 cargo test 运行.\n1 2 3 4 5 6 7 8 9 10 11 12 13  /// Adds one to the number given. /// /// # Examples /// /// ``` /// let arg = 5; /// let answer = my_crate::add_one(arg); /// /// assert_eq!(6, answer); /// ``` pubfn add_one(x: i32)-\u0026gt; i32 {x+1}  1 2 3 4 5 6 7 8  $ cargo test Doc-tests my_crate running 1 test test src/lib.rs - add_one (line 5) ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s   模块注释 //!\n14 02 Cargo Run particular package in a workspace.\n1  $ cargo run -p \u0026lt;package\u0026gt;   Test particular package in a workspace.\n1  $ cargo test -p \u0026lt;package\u0026gt;   14 04 Installling binaries 1  cargo install \u0026lt;binary name\u0026gt;   15 Smart pointers 普通的 reference 只是 borrow 了 data, 而 smart pointer 则可以是 owner.\nSmart pointer implements Deref and Drop trait.\n15 01 Box8 Box 将数据保存在 heap, 同时在 stack 上保存一个指针, 指向 heap 中的数据.\n对于递归的结构\nlet list = Cons(1, Cons(2, Cons(3, Cons(4, nil))))\n![[Pasted image 20210719122643.png]]\nRust 无法知道 list 的实际大小.\n改用 Box\nlet list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Cons(4, Box::new(nil))))))))\n![[Pasted image 20210719122659.png]]\n因为 Box 是一个指针, 有固定的大小, list 其结构不在是递归嵌套, 而是一个链表.\nBox 的使用场景:\n When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type  Check\n15 02 Deref Trait 使用 * (dereference operator) 可以沿着指针得到具体的值. 对于自定义的类型, 如果想直接使用 * , 可以实现 Deref 这个 trait.\nstruct Mybox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { ... } } let y = MyBox::new(5); 当我们使用 *y 时, Rust 实际上会这样调用 *(y.deref())\nDeref coercion 是自动发生的, 当传入的参数和方法的参数不一致时, Rust 会调用 deref 方法.\nDeref coercion 的三种情况(针对不同的 trait):\n From \u0026amp;T to \u0026amp;U when T: Deref\u0026lt;Target=U\u0026gt; From \u0026amp;mut T to \u0026amp;mut U when T: DerefMut\u0026lt;Target=U\u0026gt; From \u0026amp;mut T to \u0026amp;U when T: Deref\u0026lt;Target=U\u0026gt;  15 03 Drop Trait Must implement drop() in Drop trait.\nDrop trait is used for deallocating memory when variables leave their scope.\nAll smart pointers had implemented Drop trait.\n15 04 Rc\u0026lt;T\u0026gt; 允许多个 owner of immutable 存在.\n如果一个值可能被多处引用. 且这些引用的存活时间不一定, 可以使用 Rc\u0026lt;T\u0026gt;.\n如果一个变量可能被多处引用, 在声明的时候使用 Rc, 使用的地方调用 Rc::clone(\u0026amp;...) 就行, Rc 的 dereference 是自动的. 所以基本上不需要考虑如何使用 Rc. 另外还有一个查看计数的方法 Rc::strong_count(\u0026amp;...)\n对于自定义的结构体, 且有 impl 方法, 如果想用 RefCell 结合 Rc, 这样定义比较好:\nenum List { Cons(i32, RefCell\u0026lt;Rc\u0026lt;List\u0026gt;\u0026gt;), Nil, } impl List { fn tail(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;RefCell\u0026lt;Rc\u0026lt;List\u0026gt;\u0026gt;\u0026gt; { if let Cons(_, list) = self { Some(list) } else { None } } } enum List { Cons(i32, Rc\u0026lt;RefCell\u0026lt;List\u0026gt;\u0026gt;), Nil, } impl List { fn tail(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;Rc\u0026lt;RefCell\u0026lt;List\u0026gt;\u0026gt;\u0026gt; { if let Cons(_, list) = self { Some(list) } else { None } } } if let Some(list) = a.tail() { // tail 方法找不到 method not found in `Rc\u0026lt;RefCell\u0026lt;tests::test99_25::List\u0026gt;\u0026gt;` ... } 但是 Rc 用于 Immutable 场合, Mutable 场合怎么办呢?\n Rc\u0026lt;T\u0026gt; 只能用于单线程.\n 15 05 RefCell\u0026lt;T\u0026gt; Rust 是保守的, 即使你准守了 Borrow 规则, 但 Rust 却无法确定代码的正确性, 因此会拒绝这些代码.\n换句话说, RefCell\u0026lt;T\u0026gt; 可以将 borrow 规则的检查延迟到运行时, 这样一来, 你可以实现内部修改这一算法, 即修改那些 immutable 的变量, 但还是要遵守 borrow 规则. [[RUST#^79ef45]]\n RefCell\u0026lt;T\u0026gt; 只能用于单线程.\n RefCell 有 Rc 的计数功能. 与 Rc 的计数不同, RefCell 通过跟踪对象上的 mut 和 immut 的数量来判断是否满足 borrow 规则 (borrow rules: 同一时刻只允许一个 mut 或者 多个 immut, 不允许 mut 与 immut 同时存在), 计数到0并不意味着释放内存.\nHere is a recap of the reasons to choose Box\u0026lt;T\u0026gt;, Rc\u0026lt;T\u0026gt;, or RefCell\u0026lt;T\u0026gt;:\n Rc\u0026lt;T\u0026gt; enables multiple owners of the same data; Box\u0026lt;T\u0026gt; and RefCell\u0026lt;T\u0026gt; have single owners. Box\u0026lt;T\u0026gt; allows immutable or mutable borrows checked at compile time; Rc\u0026lt;T\u0026gt; allows only immutable borrows checked at compile time; RefCell\u0026lt;T\u0026gt; allows immutable or mutable borrows checked at runtime. Because RefCell\u0026lt;T\u0026gt; allows mutable borrows checked at runtime, you can mutate the value inside the RefCell\u0026lt;T\u0026gt; even when the RefCell\u0026lt;T\u0026gt; is immutable.  15 06 Reference Cycles - Weak\u0026lt;T\u0026gt;  Rc::downgrade(\u0026amp;...)\t// get Weak Rc::weak_count(\u0026amp;...)\t// get count \u0026amp;obj.upgrade() // see if have value of Some\u0026lt;T\u0026gt; 16 Concurrency 16 01 Using Threads 1 2 3 4 5 6  thread::spawn(||{foriin1..10{println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;,i);thread::sleep(Duration::from_millis(1));}});  16 02 Tansfer Data Between Thread let (tx, rx) = mpsc::channel(); // thread::spawn(|| { tx.send(\u0026quot;hi\u0026quot;).unwrap(); }); println!(\u0026quot;Got: {}\u0026quot;, rx.recv().unwrap()); 16 03 Share State Mutex is a mutual exclusion.\nUse Arc instead of Rc in multiple threads.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  usestd::thread;usestd::sync::{Arc,Mutex};#[test]fn test16_13(){letcounter=Arc::new(Mutex::new(0));// Arc is atomically reference counted letmuthandles=vec![];for_in0..10{letcounter=Arc::clone(\u0026amp;counter);lett=thread::spawn(move||{letmutcc=counter.lock().unwrap();*cc+=1;});handles.push(t);}fortinhandles{t.join().unwrap();}println!(\u0026#34;counter = {}\u0026#34;,*counter.lock().unwrap());}  16 04 Send Trait And Sync Trait All ownership of values of type implementing Send trait can safty tranfer between threads.\nAll values of type implementing Sync maker trait can be safty referenced from multiple threads.\nAll primitive types are Send and Sync, and any type composed entirely of Send are also Send, Sync is the same way.\n通常不需要自己实现 Send 和 Sync,\n https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html \u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html \u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/book/ch10-00-generics.html \u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/book/ch10-02-traits.html \u0026#x21a9;\u0026#xfe0e;\n The Borrow Checker \u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/book/ch11-01-writing-tests.html \u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/book/ch11-02-running-tests.html \u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/book/ch15-01-box.html \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":2,"section":"posts","tags":["rust"],"title":"Rust Programming Language","uri":"http://example.org/en/posts/rust/"},{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode\r Code tabs Make it easy to switch between different code\njava\rjavascript\r\r1  System.out.println(\u0026#39;Hello World!\u0026#39;);   \r\r1  console.log(\u0026#39;Hello World!\u0026#39;);   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"e3ccd48fd780d100\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Tabs for general purpose Windows\rMacOS\rUbuntu\r\rWindows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n\rMacOS section Hello world!\r\rUbuntu section Great!\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"11c0a9caaffdb188\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r Expand \r\rExpand me\r\rTitle contents\r\r \r\rExpand me2\r\rTitle2 contents2\r\r Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text\r info text\r warning text\r error text\r ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":3,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"http://example.org/en/posts/shortcodes/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":4,"section":"posts","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"http://example.org/en/posts/markdown-syntax/"},{"content":"Code Syntax Highlighting Verify the following code blocks render as code blocks and highlight properly.\nMore about tuning syntax highlighting is the Hugo documentation.\nDiff 1 2 3 4 5 6 7 8 9 10  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line   *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line Makefile CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I. 1 2 3 4 5  CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I.   JSON 1 2 3  {\u0026#34;employees\u0026#34;:[ {\u0026#34;firstName\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Doe\u0026#34;}, ]}   Markdown 1 2 3  **bold** *italics* [link](www.example.com)   JavaScript 1  document.write(\u0026#39;Hello, world!\u0026#39;);   CSS 1 2 3  body { background-color: red; }   Objective C 1 2 3 4 5 6  #import \u0026lt;stdio.h\u0026gt;  int main (void) { printf (\u0026#34;Hello world!\\n\u0026#34;); }   Python 1  print \u0026#34;Hello, world!\u0026#34;   XML 1 2 3 4 5  \u0026lt;employees\u0026gt; \u0026lt;employee\u0026gt; \u0026lt;firstName\u0026gt;John\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;Doe\u0026lt;/lastName\u0026gt; \u0026lt;/employee\u0026gt; \u0026lt;/employees\u0026gt;   Perl 1  print \u0026#34;Hello, World!\\n\u0026#34;;   Bash 1  echo \u0026#34;Hello World\u0026#34;   PHP 1  \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;  CoffeeScript 1  console.log(“Hello world!”);   C# 1 2 3 4 5 6 7 8  using System; class Program { public static void Main(string[] args) { Console.WriteLine(\u0026#34;Hello, world!\u0026#34;); } }   C++ 1 2 3 4 5 6 7  #include \u0026lt;iostream.h\u0026gt; main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;; return 0; }   SQL 1 2  SELECT column_name,column_name FROM table_name;   Go 1 2 3 4 5  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) }   Ruby 1  puts \u0026#34;Hello, world!\u0026#34;   Java 1 2 3 4 5 6 7 8 9 10 11 12  import javax.swing.JFrame; //Importing class JFrame import javax.swing.JLabel; //Importing class JLabel public class HelloWorld { public static void main(String[] args) { JFrame frame = new JFrame(); //Creating frame  frame.setTitle(\u0026#34;Hi!\u0026#34;); //Setting title frame  frame.add(new JLabel(\u0026#34;Hello, world!\u0026#34;));//Adding text to frame  frame.pack(); //Setting size to smallest  frame.setLocationRelativeTo(null); //Centering frame  frame.setVisible(true); //Showing frame  } }   Latex Equation 1  \\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x).   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {x, y} as p from \u0026#39;point\u0026#39;; const ANSWER = 42; class Car extends Vehicle { constructor(speed, cost) { super(speed); var c = Symbol(\u0026#39;cost\u0026#39;); this[c] = cost; this.intro = `This is a car runs at ${speed}.`; } } for (let num of [1, 2, 3]) { console.log(num + 0b111110111); } function $initHighlight(block, flags) { try { if (block.className.search(/\\bno\\-highlight\\b/) != -1) return processBlock(block.function, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;; } catch (e) { /* handle exception */ var e4x = \u0026lt;div\u0026gt;Example \u0026lt;p\u0026gt;1234\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;; } for (var i = 0 / 2; i \u0026lt; classes.length; i++) { // \u0026#34;0 / 2\u0026#34; should not be parsed as regexp  if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } console.log(Array.every(classes, Boolean)); } export $initHighlight;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello world\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;vendor/prism.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;examples.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /********************************************************* * General */ pre[class*=\u0026#34;language-\u0026#34;], code { color: #5c6e74; font-size: 13px; text-shadow: none; font-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; } pre[class*=\u0026#34;language-\u0026#34;]::selection, code::selection { text-shadow: none; background: #b3d4fc; } @media print { pre[class*=\u0026#34;language-\u0026#34;], code { text-shadow: none; } } pre[class*=\u0026#34;language-\u0026#34;] { padding: 1em; margin: .5em 0; overflow: auto; background: #f8f5ec; } :not(pre) \u0026gt; code { padding: .1em .3em; border-radius: .3em; color: #db4c69; background: #f9f2f4; }   ","description":"Syntax highlighting test","id":5,"section":"posts","tags":["hugo"],"title":"Syntax highlighting","uri":"http://example.org/en/posts/syntax-highlight/"},{"content":"We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)\r Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }}\r{{ partial \u0026quot;math.html\u0026quot; . }}\r{{ end }}\r To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","description":"A brief guide to setup KaTeX","id":6,"section":"posts","tags":null,"title":"Math Typesetting","uri":"http://example.org/en/posts/math-typesetting/"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"Guide to emoji usage in Hugo","id":7,"section":"posts","tags":["emoji","gamoji","namoji","bamoji","amoji"],"title":"Emoji Support","uri":"http://example.org/en/posts/emoji-support/"},{"content":"digraph G {\rsubgraph cluster_0 {\rstyle=filled;\rcolor=lightgrey;\rnode [style=filled,color=white];\ra0 -\u0026gt; a1 -\u0026gt; a2 -\u0026gt; a3;\rlabel = \u0026quot;process #1\u0026quot;;\r}\rsubgraph cluster_1 {\rnode [style=filled];\rb0 -\u0026gt; b1 -\u0026gt; b2 -\u0026gt; b3;\rlabel = \u0026quot;process #2\u0026quot;;\rcolor=blue\r}\rstart -\u0026gt; a0;\rstart -\u0026gt; b0;\ra1 -\u0026gt; b3;\rb2 -\u0026gt; a3;\ra3 -\u0026gt; a0;\ra3 -\u0026gt; end;\rb3 -\u0026gt; end;\rstart [shape=Mdiamond];\rend [shape=Msquare];\r}\r","description":"A hack to put Graphviz on the web.","id":8,"section":"posts","tags":[""],"title":"Viz support","uri":"http://example.org/en/posts/test-viz/"},{"content":"{ \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;},\r{\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]},\r{\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;},\r{},\r{\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;}\r]}\r","description":"WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.","id":9,"section":"posts","tags":[""],"title":"Wavedrom support","uri":"http://example.org/en/posts/test-wavedrom/"},{"content":"{\r\u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8]\r}]\r}\r}\r{\r\u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [\r{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot;\r},\r{\r\u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;,\r\u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot;\r}\r]\r}\r}\r","description":"Simple yet flexible JavaScript charting for designers \u0026 developers","id":10,"section":"posts","tags":[""],"title":"Chart support","uri":"http://example.org/en/posts/test-chartjs/"},{"content":"Alice-\u0026gt;Bob: Hello Bob, how are you?\rNote right of Bob: Bob thinks\rBob--\u0026gt;Alice: I am good thanks!\rTitle: Here is a title\rA-\u0026gt;B: Normal line\rB--\u0026gt;C: Dashed line\rC-\u0026gt;\u0026gt;D: Open arrow\rD--\u0026gt;\u0026gt;A: Dashed open arrow\r","description":"Generates UML sequence diagrams from simple text","id":11,"section":"posts","tags":[""],"title":"JS Sequence Diagram support","uri":"http://example.org/en/posts/test-js-sequence-diagrams/"},{"content":"graph TD;\rA--\u0026gt;B;\rA--\u0026gt;C;\rB--\u0026gt;D;\rC--\u0026gt;D;\rsequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail...\rJohn--\u0026gt;Alice: Great!\rJohn-\u0026gt;Bob: How about you?\rBob--\u0026gt;John: Jolly good!\rgraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2]\rgantt\rsection Section\rCompleted :done, des1, 2014-01-06,2014-01-08\rActive :active, des2, 2014-01-07, 3d\rParallel 1 : des3, after des1, 1d\rParallel 2 : des4, after des1, 1d\rParallel 3 : des5, after des3, 1d\rParallel 4 : des6, after des4, 1d\rclassDiagram\rClass01 \u0026lt;|-- AveryLongClass : Cool\r\u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01\rClass09 --\u0026gt; C2 : Where am i?\rClass09 --* C3\rClass09 --|\u0026gt; Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rclass Class10 {\r\u0026lt;\u0026lt;service\u0026gt;\u0026gt;\rint id\rsize()\r}\rstateDiagram\r[*] --\u0026gt; Still\rStill --\u0026gt; [*]\rStill --\u0026gt; Moving\rMoving --\u0026gt; Still\rMoving --\u0026gt; Crash\rCrash --\u0026gt; [*]\rpie\r\u0026quot;Dogs\u0026quot; : 386\r\u0026quot;Cats\u0026quot; : 85\r\u0026quot;Rats\u0026quot; : 15 ","description":"Generate diagrams, charts, graphs or flows from markdown-like text via javascript.","id":12,"section":"posts","tags":["diagram"],"title":"Mermaid support","uri":"http://example.org/en/posts/test-mermaid/"},{"content":"When $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\n","description":"A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.","id":13,"section":"posts","tags":[""],"title":"MathJax support","uri":"http://example.org/en/posts/test-mathjax/"},{"content":"The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\rInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math:\r$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\rBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","description":"KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.","id":14,"section":"posts","tags":[""],"title":"Katex support","uri":"http://example.org/en/posts/test-katex/"},{"content":"st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank]\re=\u0026gt;end: End|future:\u0026gt;http://www.google.com\rop1=\u0026gt;operation: My Operation|past\rop2=\u0026gt;operation: Stuff|current\rsub1=\u0026gt;subroutine: My Subroutine|invalid\rcond=\u0026gt;condition: Yes\ror No?|approved:\u0026gt;http://www.google.com\rc2=\u0026gt;condition: Good idea|rejected\rio=\u0026gt;inputoutput: catch something...|future\rst-\u0026gt;op1(right)-\u0026gt;cond\rcond(yes, right)-\u0026gt;c2\rcond(no)-\u0026gt;sub1(left)-\u0026gt;op1\rc2(yes)-\u0026gt;io-\u0026gt;e\rc2(no)-\u0026gt;op2-\u0026gt;e\r","description":"flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.","id":15,"section":"posts","tags":[""],"title":"Flowchart support","uri":"http://example.org/en/posts/test-flowchart/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":16,"section":"gallery","tags":null,"title":"Cartoon","uri":"http://example.org/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":17,"section":"gallery","tags":null,"title":"Photo","uri":"http://example.org/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":22,"section":"","tags":null,"title":"About","uri":"http://example.org/en/about/"}]